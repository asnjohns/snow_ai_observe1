-- ============================================================================
-- AI_SUCCESS_FEEDBACK Schema - View Definitions for 7 Insights
-- ============================================================================
-- Purpose: Create analytical views to support the 7 key insights
-- ============================================================================

USE DATABASE CURSOR_DB;
USE SCHEMA AI_SUCCESS_FEEDBACK;

-- ============================================================================
-- INSIGHT 1: Problematic SQL Analysis View
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_PROBLEMATIC_SQL_ANALYSIS AS
SELECT 
    r.REQUEST_ID,
    r.TIMESTAMP,
    r.SEMANTIC_MODEL_NAME,
    r.SEMANTIC_MODEL_TYPE,
    r.USER_ID,
    r.USER_NAME,
    r.LATEST_QUESTION,
    r.GENERATED_SQL,
    r.RESPONSE_STATUS_CODE,
    
    -- Categorize problem type
    CASE 
        WHEN r.RESPONSE_STATUS_CODE != 200 THEN 'EXECUTION_ERROR'
        WHEN r.WARNINGS IS NOT NULL AND ARRAY_SIZE(r.WARNINGS) > 0 THEN 'HAS_WARNINGS'
        WHEN LENGTH(r.GENERATED_SQL) > 5000 THEN 'COMPLEX_SQL'
        WHEN r.GENERATED_SQL IS NULL THEN 'NO_SQL_GENERATED'
        ELSE 'OTHER'
    END AS PROBLEM_TYPE,
    
    -- Calculate SQL complexity score
    (COALESCE(LENGTH(r.GENERATED_SQL), 0) / 100.0) + 
    (REGEXP_COUNT(r.GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
    (REGEXP_COUNT(r.GENERATED_SQL, 'WHERE', 1, 'i') * 1) +
    (REGEXP_COUNT(r.GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) +
    (REGEXP_COUNT(r.GENERATED_SQL, 'HAVING', 1, 'i') * 2) +
    (REGEXP_COUNT(r.GENERATED_SQL, 'CASE', 1, 'i') * 1.5) +
    (REGEXP_COUNT(r.GENERATED_SQL, 'UNION', 1, 'i') * 3) +
    (REGEXP_COUNT(r.GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') * 2.5) AS SQL_COMPLEXITY_SCORE,
    
    -- Complexity category
    CASE 
        WHEN (COALESCE(LENGTH(r.GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(r.GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(r.GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) < 5 THEN 'SIMPLE'
        WHEN (COALESCE(LENGTH(r.GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(r.GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(r.GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) < 15 THEN 'MODERATE'
        ELSE 'COMPLEX'
    END AS COMPLEXITY_CATEGORY,
    
    r.WARNINGS,
    ARRAY_SIZE(r.WARNINGS) AS WARNING_COUNT,
    r.FEEDBACK,
    ARRAY_SIZE(r.FEEDBACK) AS FEEDBACK_COUNT,
    r.TABLES_REFERENCED,
    r.LOADED_AT
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY r
WHERE r.RESPONSE_STATUS_CODE != 200 
   OR (r.WARNINGS IS NOT NULL AND ARRAY_SIZE(r.WARNINGS) > 0)
   OR (r.FEEDBACK IS NOT NULL AND ARRAY_SIZE(r.FEEDBACK) > 0);

-- ============================================================================
-- INSIGHT 2: Response Status Code Failures and Patterns
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_RESPONSE_STATUS_FAILURES AS
SELECT 
    RESPONSE_STATUS_CODE,
    CASE 
        WHEN RESPONSE_STATUS_CODE = 200 THEN 'SUCCESS'
        WHEN RESPONSE_STATUS_CODE = 400 THEN 'BAD_REQUEST'
        WHEN RESPONSE_STATUS_CODE = 401 THEN 'UNAUTHORIZED'
        WHEN RESPONSE_STATUS_CODE = 403 THEN 'FORBIDDEN'
        WHEN RESPONSE_STATUS_CODE = 404 THEN 'NOT_FOUND'
        WHEN RESPONSE_STATUS_CODE = 500 THEN 'INTERNAL_SERVER_ERROR'
        WHEN RESPONSE_STATUS_CODE = 503 THEN 'SERVICE_UNAVAILABLE'
        ELSE 'OTHER_ERROR'
    END AS ERROR_CATEGORY,
    SEMANTIC_MODEL_NAME,
    DATE_TRUNC('DAY', TIMESTAMP) AS FAILURE_DATE,
    DATE_TRUNC('HOUR', TIMESTAMP) AS FAILURE_HOUR,
    COUNT(*) AS FAILURE_COUNT,
    COUNT(DISTINCT USER_ID) AS AFFECTED_USERS,
    COUNT(DISTINCT LATEST_QUESTION) AS UNIQUE_QUESTIONS,
    MIN(TIMESTAMP) AS FIRST_FAILURE,
    MAX(TIMESTAMP) AS LAST_FAILURE
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE RESPONSE_STATUS_CODE != 200
GROUP BY 
    RESPONSE_STATUS_CODE, 
    SEMANTIC_MODEL_NAME, 
    DATE_TRUNC('DAY', TIMESTAMP),
    DATE_TRUNC('HOUR', TIMESTAMP);

-- ============================================================================
-- INSIGHT 2B: Status Code Trend Analysis
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_STATUS_CODE_TRENDS AS
SELECT 
    DATE_TRUNC('DAY', TIMESTAMP) AS REQUEST_DATE,
    RESPONSE_STATUS_CODE,
    CASE 
        WHEN RESPONSE_STATUS_CODE = 200 THEN 'SUCCESS'
        WHEN RESPONSE_STATUS_CODE = 400 THEN 'BAD_REQUEST'
        WHEN RESPONSE_STATUS_CODE = 401 THEN 'UNAUTHORIZED'
        WHEN RESPONSE_STATUS_CODE = 403 THEN 'FORBIDDEN'
        WHEN RESPONSE_STATUS_CODE = 404 THEN 'NOT_FOUND'
        WHEN RESPONSE_STATUS_CODE = 500 THEN 'INTERNAL_SERVER_ERROR'
        WHEN RESPONSE_STATUS_CODE = 503 THEN 'SERVICE_UNAVAILABLE'
        ELSE 'OTHER_ERROR'
    END AS ERROR_CATEGORY,
    COUNT(*) AS OCCURRENCE_COUNT,
    COUNT(DISTINCT SEMANTIC_MODEL_NAME) AS AFFECTED_MODELS,
    COUNT(DISTINCT USER_ID) AS AFFECTED_USERS
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
GROUP BY DATE_TRUNC('DAY', TIMESTAMP), RESPONSE_STATUS_CODE
ORDER BY REQUEST_DATE DESC, OCCURRENCE_COUNT DESC;

-- ============================================================================
-- INSIGHT 3: Warning Patterns and Recurring Issues
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_WARNING_PATTERNS AS
SELECT 
    r.REQUEST_ID,
    r.TIMESTAMP,
    r.SEMANTIC_MODEL_NAME,
    r.USER_ID,
    r.USER_NAME,
    r.LATEST_QUESTION,
    r.GENERATED_SQL,
    r.WARNINGS,
    ARRAY_SIZE(r.WARNINGS) AS WARNING_COUNT,
    w.value::STRING AS WARNING_DETAIL,
    r.RESPONSE_STATUS_CODE,
    r.FEEDBACK
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY r,
LATERAL FLATTEN(input => r.WARNINGS) w
WHERE r.WARNINGS IS NOT NULL 
  AND ARRAY_SIZE(r.WARNINGS) > 0;

-- ============================================================================
-- INSIGHT 3B: Warning Summary by Type
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_WARNING_SUMMARY AS
SELECT 
    w.value::STRING AS WARNING_MESSAGE,
    COUNT(*) AS OCCURRENCE_COUNT,
    COUNT(DISTINCT r.SEMANTIC_MODEL_NAME) AS AFFECTED_MODELS,
    COUNT(DISTINCT r.USER_ID) AS AFFECTED_USERS,
    MIN(r.TIMESTAMP) AS FIRST_OCCURRENCE,
    MAX(r.TIMESTAMP) AS LAST_OCCURRENCE,
    AVG(ARRAY_SIZE(r.WARNINGS)) AS AVG_WARNINGS_PER_REQUEST
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY r,
LATERAL FLATTEN(input => r.WARNINGS) w
WHERE r.WARNINGS IS NOT NULL 
  AND ARRAY_SIZE(r.WARNINGS) > 0
GROUP BY w.value::STRING
ORDER BY OCCURRENCE_COUNT DESC;

-- ============================================================================
-- INSIGHT 4: Feedback Rates by Semantic Model
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_FEEDBACK_RATES_BY_MODEL AS
SELECT 
    SEMANTIC_MODEL_NAME,
    SEMANTIC_MODEL_TYPE,
    COUNT(*) AS TOTAL_REQUESTS,
    SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END) AS SUCCESSFUL_REQUESTS,
    SUM(CASE WHEN FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 THEN 1 ELSE 0 END) AS REQUESTS_WITH_FEEDBACK,
    
    -- Feedback rate
    ROUND(SUM(CASE WHEN FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 THEN 1 ELSE 0 END)::FLOAT / 
          NULLIF(COUNT(*), 0) * 100, 2) AS FEEDBACK_RATE_PCT,
    
    -- Success rate
    ROUND(SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END)::FLOAT / 
          NULLIF(COUNT(*), 0) * 100, 2) AS SUCCESS_RATE_PCT,
    
    -- Average feedback count
    AVG(ARRAY_SIZE(FEEDBACK)) AS AVG_FEEDBACK_COUNT,
    
    -- Date range
    MIN(TIMESTAMP) AS FIRST_REQUEST,
    MAX(TIMESTAMP) AS LAST_REQUEST,
    
    -- User engagement
    COUNT(DISTINCT USER_ID) AS UNIQUE_USERS,
    
    -- Warning stats
    SUM(CASE WHEN WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0 THEN 1 ELSE 0 END) AS REQUESTS_WITH_WARNINGS
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
GROUP BY SEMANTIC_MODEL_NAME, SEMANTIC_MODEL_TYPE
ORDER BY TOTAL_REQUESTS DESC;

-- ============================================================================
-- INSIGHT 5: Question Types with Poor Feedback
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_POOR_FEEDBACK_BY_QUESTION_TYPE AS
SELECT 
    -- Categorize question types
    CASE 
        WHEN LATEST_QUESTION ILIKE '%how many%' OR LATEST_QUESTION ILIKE '%count%' THEN 'COUNT_QUERY'
        WHEN LATEST_QUESTION ILIKE '%sum%' OR LATEST_QUESTION ILIKE '%total%' THEN 'AGGREGATION_QUERY'
        WHEN LATEST_QUESTION ILIKE '%average%' OR LATEST_QUESTION ILIKE '%avg%' OR LATEST_QUESTION ILIKE '%mean%' THEN 'AVERAGE_QUERY'
        WHEN LATEST_QUESTION ILIKE '%top%' OR LATEST_QUESTION ILIKE '%highest%' OR LATEST_QUESTION ILIKE '%maximum%' THEN 'TOP_N_QUERY'
        WHEN LATEST_QUESTION ILIKE '%bottom%' OR LATEST_QUESTION ILIKE '%lowest%' OR LATEST_QUESTION ILIKE '%minimum%' THEN 'BOTTOM_N_QUERY'
        WHEN LATEST_QUESTION ILIKE '%compare%' OR LATEST_QUESTION ILIKE '%comparison%' THEN 'COMPARISON_QUERY'
        WHEN LATEST_QUESTION ILIKE '%trend%' OR LATEST_QUESTION ILIKE '%over time%' THEN 'TREND_QUERY'
        WHEN LATEST_QUESTION ILIKE '%show%' OR LATEST_QUESTION ILIKE '%list%' OR LATEST_QUESTION ILIKE '%get%' THEN 'LIST_QUERY'
        WHEN LATEST_QUESTION ILIKE '%filter%' OR LATEST_QUESTION ILIKE '%where%' THEN 'FILTER_QUERY'
        ELSE 'OTHER_QUERY'
    END AS QUESTION_TYPE,
    
    SEMANTIC_MODEL_NAME,
    COUNT(*) AS TOTAL_QUESTIONS,
    SUM(CASE WHEN FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 THEN 1 ELSE 0 END) AS QUESTIONS_WITH_FEEDBACK,
    SUM(CASE WHEN RESPONSE_STATUS_CODE != 200 THEN 1 ELSE 0 END) AS FAILED_QUESTIONS,
    ROUND(SUM(CASE WHEN RESPONSE_STATUS_CODE != 200 THEN 1 ELSE 0 END)::FLOAT / 
          NULLIF(COUNT(*), 0) * 100, 2) AS FAILURE_RATE_PCT,
    AVG(LENGTH(LATEST_QUESTION)) AS AVG_QUESTION_LENGTH,
    AVG(LENGTH(GENERATED_SQL)) AS AVG_SQL_LENGTH
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE LATEST_QUESTION IS NOT NULL
GROUP BY QUESTION_TYPE, SEMANTIC_MODEL_NAME
ORDER BY FAILURE_RATE_PCT DESC, TOTAL_QUESTIONS DESC;

-- ============================================================================
-- INSIGHT 6: SQL Complexity vs User Satisfaction Correlation
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_COMPLEXITY_SATISFACTION_CORRELATION AS
SELECT 
    REQUEST_ID,
    TIMESTAMP,
    SEMANTIC_MODEL_NAME,
    USER_ID,
    LATEST_QUESTION,
    GENERATED_SQL,
    
    -- SQL Complexity Metrics
    LENGTH(GENERATED_SQL) AS SQL_LENGTH,
    REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') AS JOIN_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') AS GROUP_BY_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') AS SUBQUERY_COUNT,
    
    -- Complexity Score
    (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
    (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') * 1) +
    (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'HAVING', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'CASE', 1, 'i') * 1.5) +
    (REGEXP_COUNT(GENERATED_SQL, 'UNION', 1, 'i') * 3) +
    (REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') * 2.5) AS SQL_COMPLEXITY_SCORE,
    
    -- Complexity Category
    CASE 
        WHEN (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) < 5 THEN 'SIMPLE'
        WHEN (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) < 15 THEN 'MODERATE'
        ELSE 'COMPLEX'
    END AS COMPLEXITY_CATEGORY,
    
    -- Satisfaction Indicators
    RESPONSE_STATUS_CODE,
    CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 'SUCCESS' ELSE 'FAILURE' END AS EXECUTION_STATUS,
    FEEDBACK,
    ARRAY_SIZE(FEEDBACK) AS FEEDBACK_COUNT,
    WARNINGS,
    ARRAY_SIZE(WARNINGS) AS WARNING_COUNT,
    
    -- Combined satisfaction score (lower is better)
    CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 0 ELSE 10 END +
    COALESCE(ARRAY_SIZE(WARNINGS), 0) * 2 +
    COALESCE(ARRAY_SIZE(FEEDBACK), 0) * 1 AS DISSATISFACTION_SCORE
    
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE GENERATED_SQL IS NOT NULL;

-- ============================================================================
-- INSIGHT 6B: Complexity-Satisfaction Summary
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_COMPLEXITY_SATISFACTION_SUMMARY AS
SELECT 
    CASE 
        WHEN (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) < 5 THEN 'SIMPLE'
        WHEN (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) < 15 THEN 'MODERATE'
        ELSE 'COMPLEX'
    END AS COMPLEXITY_CATEGORY,
    
    SEMANTIC_MODEL_NAME,
    COUNT(*) AS TOTAL_QUERIES,
    SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END) AS SUCCESSFUL_QUERIES,
    ROUND(SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END)::FLOAT / 
          NULLIF(COUNT(*), 0) * 100, 2) AS SUCCESS_RATE_PCT,
    SUM(CASE WHEN FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 THEN 1 ELSE 0 END) AS QUERIES_WITH_FEEDBACK,
    SUM(CASE WHEN WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0 THEN 1 ELSE 0 END) AS QUERIES_WITH_WARNINGS,
    AVG(LENGTH(GENERATED_SQL)) AS AVG_SQL_LENGTH,
    
    -- Average complexity score
    AVG((COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
        (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
        (REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') * 1) +
        (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2)) AS AVG_COMPLEXITY_SCORE
    
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE GENERATED_SQL IS NOT NULL
GROUP BY COMPLEXITY_CATEGORY, SEMANTIC_MODEL_NAME
ORDER BY COMPLEXITY_CATEGORY, SEMANTIC_MODEL_NAME;

-- ============================================================================
-- INSIGHT 7: SQL Correctness vs User Expectations Discrepancies
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_CORRECTNESS_EXPECTATION_GAPS AS
SELECT 
    REQUEST_ID,
    TIMESTAMP,
    SEMANTIC_MODEL_NAME,
    USER_ID,
    USER_NAME,
    LATEST_QUESTION,
    GENERATED_SQL,
    
    -- Technical correctness
    RESPONSE_STATUS_CODE,
    CASE 
        WHEN RESPONSE_STATUS_CODE = 200 THEN 'TECHNICALLY_CORRECT'
        ELSE 'TECHNICAL_ERROR'
    END AS TECHNICAL_STATUS,
    
    -- User satisfaction indicators
    FEEDBACK,
    ARRAY_SIZE(FEEDBACK) AS FEEDBACK_COUNT,
    WARNINGS,
    ARRAY_SIZE(WARNINGS) AS WARNING_COUNT,
    
    -- SQL characteristics
    LENGTH(GENERATED_SQL) AS SQL_LENGTH,
    (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
    (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) AS SQL_COMPLEXITY_SCORE,
    
    -- Identify potential discrepancies
    CASE 
        WHEN RESPONSE_STATUS_CODE = 200 AND FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 
            THEN 'CORRECT_BUT_FEEDBACK_PROVIDED'
        WHEN RESPONSE_STATUS_CODE = 200 AND WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0 
            THEN 'CORRECT_BUT_HAS_WARNINGS'
        WHEN RESPONSE_STATUS_CODE = 200 AND GENERATED_SQL IS NULL 
            THEN 'SUCCESS_BUT_NO_SQL'
        ELSE 'NO_DISCREPANCY_DETECTED'
    END AS DISCREPANCY_TYPE,
    
    TABLES_REFERENCED,
    RESPONSE_BODY
    
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE RESPONSE_STATUS_CODE = 200  -- Technically correct
  AND (
      (FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0)  -- But has feedback
      OR (WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0)  -- Or has warnings
      OR GENERATED_SQL IS NULL  -- Or no SQL generated
  );

-- ============================================================================
-- INSIGHT 7B: Expectation Gap Summary
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_SUCCESS_FEEDBACK.VW_EXPECTATION_GAP_SUMMARY AS
SELECT 
    SEMANTIC_MODEL_NAME,
    DATE_TRUNC('DAY', TIMESTAMP) AS ANALYSIS_DATE,
    
    -- Technically correct but potentially unsatisfactory
    COUNT(CASE 
        WHEN RESPONSE_STATUS_CODE = 200 
         AND (FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0)
        THEN 1 
    END) AS CORRECT_WITH_FEEDBACK,
    
    COUNT(CASE 
        WHEN RESPONSE_STATUS_CODE = 200 
         AND (WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0)
        THEN 1 
    END) AS CORRECT_WITH_WARNINGS,
    
    COUNT(CASE 
        WHEN RESPONSE_STATUS_CODE = 200 
         AND GENERATED_SQL IS NULL
        THEN 1 
    END) AS CORRECT_NO_SQL,
    
    -- Total successful requests
    COUNT(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 END) AS TOTAL_SUCCESSFUL,
    
    -- Gap rate
    ROUND(
        COUNT(CASE 
            WHEN RESPONSE_STATUS_CODE = 200 
             AND ((FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0)
                  OR (WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0))
            THEN 1 
        END)::FLOAT / 
        NULLIF(COUNT(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 END), 0) * 100, 
        2
    ) AS EXPECTATION_GAP_RATE_PCT
    
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
GROUP BY SEMANTIC_MODEL_NAME, DATE_TRUNC('DAY', TIMESTAMP)
ORDER BY ANALYSIS_DATE DESC, EXPECTATION_GAP_RATE_PCT DESC;

SELECT 'All views created successfully for 7 insights' AS STATUS;



