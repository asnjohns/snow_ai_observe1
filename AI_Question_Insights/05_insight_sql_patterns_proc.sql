-- ============================================================================
-- Stored Procedure: GET_SQL_PATTERN_ANALYSIS
-- Purpose: Analyze common SQL patterns that emerge from user questions
-- 
-- Returns: Result set with SQL pattern metrics including:
--   - Common SQL constructs and patterns
--   - Join patterns and complexity
--   - Aggregation patterns
--   - Filter and WHERE clause patterns
--   - CTE and subquery usage
-- 
-- Usage: CALL CURSOR_DB.AI_QUESTION_INSIGHTS.GET_SQL_PATTERN_ANALYSIS(30, 30);
-- ============================================================================

CREATE OR REPLACE PROCEDURE CURSOR_DB.AI_QUESTION_INSIGHTS.GET_SQL_PATTERN_ANALYSIS(
    DAYS_BACK INTEGER DEFAULT 30,
    TOP_N_PATTERNS INTEGER DEFAULT 30
)
RETURNS TABLE (
    PATTERN_TYPE VARCHAR,
    PATTERN_NAME VARCHAR,
    OCCURRENCE_COUNT INTEGER,
    PERCENTAGE_OF_QUERIES FLOAT,
    AVG_QUERY_COMPLEXITY FLOAT,
    SUCCESS_RATE FLOAT,
    AVG_EXECUTION_SUCCESS FLOAT,
    UNIQUE_USERS_USING INTEGER,
    SAMPLE_SQL ARRAY,
    RELATED_QUESTIONS ARRAY,
    COMMON_TABLES_USED ARRAY,
    FIRST_OCCURRENCE TIMESTAMP_NTZ,
    LAST_OCCURRENCE TIMESTAMP_NTZ,
    IS_COMPLEX_PATTERN BOOLEAN,
    RECOMMENDATION VARCHAR
)
LANGUAGE SQL
COMMENT = 'Analyze SQL patterns generated by Cortex Analyst to identify common structures and anti-patterns'
AS
$$
DECLARE
    start_date TIMESTAMP_NTZ;
    total_queries INTEGER;
    result_set RESULTSET;
BEGIN
    start_date := DATEADD('day', -:DAYS_BACK, CURRENT_TIMESTAMP());
    
    -- Get total query count for percentage calculations
    SELECT COUNT(*) INTO :total_queries
    FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
    WHERE TIMESTAMP >= :start_date
      AND GENERATED_SQL IS NOT NULL;
    
    result_set := (
        WITH sql_base AS (
            -- Base SQL data with pattern indicators
            SELECT 
                REQUEST_ID,
                TIMESTAMP,
                USER_NAME,
                LATEST_QUESTION,
                GENERATED_SQL,
                RESPONSE_STATUS_CODE,
                TABLES_REFERENCED,
                -- Detect various SQL patterns
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bJOIN\\b', 'i') THEN 1 ELSE 0 END as has_join,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bLEFT\\s+JOIN\\b', 'i') THEN 1 ELSE 0 END as has_left_join,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bINNER\\s+JOIN\\b', 'i') THEN 1 ELSE 0 END as has_inner_join,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bGROUP\\s+BY\\b', 'i') THEN 1 ELSE 0 END as has_group_by,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bHAVING\\b', 'i') THEN 1 ELSE 0 END as has_having,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bORDER\\s+BY\\b', 'i') THEN 1 ELSE 0 END as has_order_by,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bWITH\\b', 'i') THEN 1 ELSE 0 END as has_cte,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bCASE\\s+WHEN\\b', 'i') THEN 1 ELSE 0 END as has_case,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bSUBSTRING\\b|\\bCONCAT\\b|\\bLOWER\\b|\\bUPPER\\b', 'i') THEN 1 ELSE 0 END as has_string_func,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bDATE_TRUNC\\b|\\bDATEADD\\b|\\bDATEDIFF\\b', 'i') THEN 1 ELSE 0 END as has_date_func,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bSUM\\b|\\bAVG\\b|\\bCOUNT\\b|\\bMIN\\b|\\bMAX\\b', 'i') THEN 1 ELSE 0 END as has_aggregation,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bWINDOW\\b|\\bOVER\\s*\\(', 'i') THEN 1 ELSE 0 END as has_window_func,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bUNION\\b', 'i') THEN 1 ELSE 0 END as has_union,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bIN\\s*\\(\\s*SELECT\\b', 'i') THEN 1 ELSE 0 END as has_subquery,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bEXISTS\\b', 'i') THEN 1 ELSE 0 END as has_exists,
                CASE WHEN REGEXP_LIKE(GENERATED_SQL, '\\bDISTINCT\\b', 'i') THEN 1 ELSE 0 END as has_distinct,
                -- Count number of joins
                ARRAY_SIZE(REGEXP_SUBSTR_ALL(GENERATED_SQL, 'JOIN', 1, 1, 'i')) as join_count,
                -- Calculate complexity score
                LENGTH(GENERATED_SQL) / 50.0 as length_score
            FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
            WHERE TIMESTAMP >= :start_date
              AND GENERATED_SQL IS NOT NULL
        ),
        pattern_occurrences AS (
            -- Flatten patterns into rows
            SELECT 
                REQUEST_ID,
                TIMESTAMP,
                USER_NAME,
                LATEST_QUESTION,
                GENERATED_SQL,
                RESPONSE_STATUS_CODE,
                TABLES_REFERENCED,
                pattern_type,
                pattern_name,
                join_count,
                length_score,
                CASE 
                    WHEN join_count > 3 OR length_score > 20 THEN TRUE
                    ELSE FALSE
                END as is_complex
            FROM sql_base
            UNPIVOT (
                pattern_value FOR pattern_type IN (
                    has_join, has_left_join, has_inner_join, has_group_by, 
                    has_having, has_order_by, has_cte, has_case, 
                    has_string_func, has_date_func, has_aggregation, 
                    has_window_func, has_union, has_subquery, 
                    has_exists, has_distinct
                )
            )
            WHERE pattern_value = 1
        ),
        pattern_mapped AS (
            -- Map pattern types to readable names and categories
            SELECT 
                REQUEST_ID,
                TIMESTAMP,
                USER_NAME,
                LATEST_QUESTION,
                GENERATED_SQL,
                RESPONSE_STATUS_CODE,
                TABLES_REFERENCED,
                is_complex,
                CASE 
                    WHEN pattern_type = 'HAS_JOIN' THEN 'Join Pattern'
                    WHEN pattern_type = 'HAS_LEFT_JOIN' THEN 'Join Pattern'
                    WHEN pattern_type = 'HAS_INNER_JOIN' THEN 'Join Pattern'
                    WHEN pattern_type = 'HAS_AGGREGATION' THEN 'Aggregation Pattern'
                    WHEN pattern_type = 'HAS_GROUP_BY' THEN 'Aggregation Pattern'
                    WHEN pattern_type = 'HAS_WINDOW_FUNC' THEN 'Window Function'
                    WHEN pattern_type = 'HAS_CTE' THEN 'CTE Usage'
                    WHEN pattern_type = 'HAS_DATE_FUNC' THEN 'Date Manipulation'
                    WHEN pattern_type = 'HAS_STRING_FUNC' THEN 'String Manipulation'
                    WHEN pattern_type = 'HAS_SUBQUERY' THEN 'Subquery Pattern'
                    WHEN pattern_type = 'HAS_CASE' THEN 'Conditional Logic'
                    ELSE 'Other'
                END as pattern_category,
                CASE 
                    WHEN pattern_type = 'HAS_JOIN' THEN 'Generic JOIN'
                    WHEN pattern_type = 'HAS_LEFT_JOIN' THEN 'LEFT JOIN'
                    WHEN pattern_type = 'HAS_INNER_JOIN' THEN 'INNER JOIN'
                    WHEN pattern_type = 'HAS_AGGREGATION' THEN 'Aggregation Functions (SUM/AVG/COUNT)'
                    WHEN pattern_type = 'HAS_GROUP_BY' THEN 'GROUP BY Clause'
                    WHEN pattern_type = 'HAS_HAVING' THEN 'HAVING Clause'
                    WHEN pattern_type = 'HAS_ORDER_BY' THEN 'ORDER BY Clause'
                    WHEN pattern_type = 'HAS_WINDOW_FUNC' THEN 'Window Functions (OVER)'
                    WHEN pattern_type = 'HAS_CTE' THEN 'Common Table Expression (WITH)'
                    WHEN pattern_type = 'HAS_DATE_FUNC' THEN 'Date Functions'
                    WHEN pattern_type = 'HAS_STRING_FUNC' THEN 'String Functions'
                    WHEN pattern_type = 'HAS_SUBQUERY' THEN 'Subquery (IN/EXISTS)'
                    WHEN pattern_type = 'HAS_CASE' THEN 'CASE WHEN Statement'
                    WHEN pattern_type = 'HAS_UNION' THEN 'UNION'
                    WHEN pattern_type = 'HAS_DISTINCT' THEN 'DISTINCT'
                    WHEN pattern_type = 'HAS_EXISTS' THEN 'EXISTS Clause'
                    ELSE pattern_type
                END as pattern_name
            FROM pattern_occurrences
        ),
        pattern_metrics AS (
            -- Calculate metrics for each pattern
            SELECT 
                pattern_category as pattern_type,
                pattern_name,
                COUNT(*) as occurrence_count,
                ROUND(COUNT(*) * 100.0 / NULLIF(:total_queries, 0), 2) as pct_of_queries,
                COUNT(DISTINCT USER_NAME) as unique_users,
                ROUND(SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0), 3) as success_rate,
                ROUND(AVG(CASE WHEN is_complex THEN 1 ELSE 0 END), 3) as avg_complexity,
                MIN(TIMESTAMP) as first_occurrence,
                MAX(TIMESTAMP) as last_occurrence,
                SUM(CASE WHEN is_complex THEN 1 ELSE 0 END) as complex_count
            FROM pattern_mapped
            GROUP BY pattern_category, pattern_name
        ),
        pattern_samples AS (
            -- Collect sample SQL for each pattern
            SELECT 
                pattern_category,
                pattern_name,
                ARRAY_AGG(GENERATED_SQL) WITHIN GROUP (ORDER BY TIMESTAMP DESC) as sample_sql
            FROM (
                SELECT 
                    pattern_category,
                    pattern_name,
                    GENERATED_SQL,
                    TIMESTAMP,
                    ROW_NUMBER() OVER (PARTITION BY pattern_category, pattern_name ORDER BY TIMESTAMP DESC) as rn
                FROM pattern_mapped
            )
            WHERE rn <= 3  -- Keep 3 samples per pattern
            GROUP BY pattern_category, pattern_name
        ),
        pattern_questions AS (
            -- Collect related questions for each pattern
            SELECT 
                pattern_category,
                pattern_name,
                ARRAY_AGG(LATEST_QUESTION) WITHIN GROUP (ORDER BY TIMESTAMP DESC) as related_questions
            FROM (
                SELECT 
                    pattern_category,
                    pattern_name,
                    LATEST_QUESTION,
                    TIMESTAMP,
                    ROW_NUMBER() OVER (PARTITION BY pattern_category, pattern_name ORDER BY TIMESTAMP DESC) as rn
                FROM pattern_mapped
                WHERE LATEST_QUESTION IS NOT NULL
            )
            WHERE rn <= 5  -- Keep 5 questions per pattern
            GROUP BY pattern_category, pattern_name
        ),
        pattern_tables AS (
            -- Identify common tables for each pattern
            SELECT 
                pm.pattern_category,
                pm.pattern_name,
                ARRAY_AGG(DISTINCT t.value::STRING) WITHIN GROUP (ORDER BY COUNT(*) DESC) as common_tables
            FROM pattern_mapped pm,
                 LATERAL FLATTEN(input => pm.TABLES_REFERENCED) t
            GROUP BY pm.pattern_category, pm.pattern_name
        )
        -- Combine all pattern metrics with recommendations
        SELECT 
            pm.pattern_type,
            pm.pattern_name,
            pm.occurrence_count,
            pm.pct_of_queries as percentage_of_queries,
            pm.avg_complexity as avg_query_complexity,
            pm.success_rate,
            pm.success_rate as avg_execution_success,
            pm.unique_users as unique_users_using,
            COALESCE(ps.sample_sql, ARRAY_CONSTRUCT()) as sample_sql,
            COALESCE(pq.related_questions, ARRAY_CONSTRUCT()) as related_questions,
            COALESCE(ARRAY_SLICE(pt.common_tables, 0, 10), ARRAY_CONSTRUCT()) as common_tables_used,
            pm.first_occurrence,
            pm.last_occurrence,
            CASE WHEN pm.complex_count > pm.occurrence_count * 0.5 THEN TRUE ELSE FALSE END as is_complex_pattern,
            CASE 
                WHEN pm.success_rate < 0.7 THEN 'Review semantic model - low success rate'
                WHEN pm.avg_complexity > 0.8 THEN 'Consider simplifying query patterns'
                WHEN pm.occurrence_count > :total_queries * 0.3 THEN 'Common pattern - ensure optimal performance'
                ELSE 'Pattern performing well'
            END as recommendation
        FROM pattern_metrics pm
        LEFT JOIN pattern_samples ps ON pm.pattern_type = ps.pattern_category AND pm.pattern_name = ps.pattern_name
        LEFT JOIN pattern_questions pq ON pm.pattern_type = pq.pattern_category AND pm.pattern_name = pq.pattern_name
        LEFT JOIN pattern_tables pt ON pm.pattern_type = pt.pattern_category AND pm.pattern_name = pt.pattern_name
        ORDER BY pm.occurrence_count DESC
        LIMIT :TOP_N_PATTERNS
    );
    
    RETURN TABLE(result_set);
END;
$$;

