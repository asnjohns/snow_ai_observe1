-- ============================================================================
-- Enhanced Views for AI_QUESTION_INSIGHTS Schema
-- ============================================================================
-- Execute these as ACCOUNTADMIN after running 00_GRANT_PERMISSIONS.sql
-- ============================================================================

USE ROLE ACCOUNTADMIN;
USE DATABASE CURSOR_DB;
USE SCHEMA AI_QUESTION_INSIGHTS;

-- ============================================================================
-- View 1: VW_ERROR_ANALYSIS - Enhanced error analysis with SQL complexity
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_ERROR_ANALYSIS AS
SELECT 
    REQUEST_ID,
    TIMESTAMP,
    SEMANTIC_MODEL_TYPE,
    SEMANTIC_MODEL_NAME,
    USER_ID,
    USER_NAME,
    SOURCE,
    LATEST_QUESTION,
    GENERATED_SQL,
    RESPONSE_STATUS_CODE,
    
    -- Error categorization
    CASE 
        WHEN RESPONSE_STATUS_CODE = 200 THEN 'SUCCESS'
        WHEN RESPONSE_STATUS_CODE = 400 THEN 'BAD_REQUEST'
        WHEN RESPONSE_STATUS_CODE = 401 THEN 'UNAUTHORIZED'
        WHEN RESPONSE_STATUS_CODE = 403 THEN 'FORBIDDEN'
        WHEN RESPONSE_STATUS_CODE = 404 THEN 'NOT_FOUND'
        WHEN RESPONSE_STATUS_CODE = 500 THEN 'INTERNAL_SERVER_ERROR'
        WHEN RESPONSE_STATUS_CODE = 503 THEN 'SERVICE_UNAVAILABLE'
        ELSE 'OTHER_ERROR'
    END AS ERROR_CATEGORY,
    
    -- Warning analysis
    WARNINGS,
    ARRAY_SIZE(WARNINGS) AS WARNING_COUNT,
    
    -- Feedback analysis
    FEEDBACK,
    ARRAY_SIZE(FEEDBACK) AS FEEDBACK_COUNT,
    
    -- SQL complexity metrics
    LENGTH(GENERATED_SQL) AS SQL_LENGTH,
    REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') AS JOIN_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') AS WHERE_CLAUSE_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') AS GROUP_BY_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'ORDER BY', 1, 'i') AS ORDER_BY_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'HAVING', 1, 'i') AS HAVING_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'CASE', 1, 'i') AS CASE_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'UNION', 1, 'i') AS UNION_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') AS SUBQUERY_COUNT,
    
    -- Calculate SQL complexity score
    (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
    (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') * 1) +
    (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'HAVING', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'CASE', 1, 'i') * 1.5) +
    (REGEXP_COUNT(GENERATED_SQL, 'UNION', 1, 'i') * 3) +
    (REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') * 2.5) AS SQL_COMPLEXITY_SCORE,
    
    TABLES_REFERENCED,
    REQUEST_BODY,
    RESPONSE_BODY,
    RESPONSE_METADATA,
    PRIMARY_ROLE_NAME,
    LOADED_AT
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY;

-- ============================================================================
-- View 2: VW_RESPONSE_STATUS_SUMMARY - Status code patterns and trends
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_RESPONSE_STATUS_SUMMARY AS
SELECT 
    DATE_TRUNC('DAY', TIMESTAMP) AS REQUEST_DATE,
    RESPONSE_STATUS_CODE,
    CASE 
        WHEN RESPONSE_STATUS_CODE = 200 THEN 'SUCCESS'
        WHEN RESPONSE_STATUS_CODE = 400 THEN 'BAD_REQUEST'
        WHEN RESPONSE_STATUS_CODE = 401 THEN 'UNAUTHORIZED'
        WHEN RESPONSE_STATUS_CODE = 403 THEN 'FORBIDDEN'
        WHEN RESPONSE_STATUS_CODE = 404 THEN 'NOT_FOUND'
        WHEN RESPONSE_STATUS_CODE = 500 THEN 'INTERNAL_SERVER_ERROR'
        WHEN RESPONSE_STATUS_CODE = 503 THEN 'SERVICE_UNAVAILABLE'
        ELSE 'OTHER_ERROR'
    END AS STATUS_CATEGORY,
    SEMANTIC_MODEL_NAME,
    COUNT(*) AS REQUEST_COUNT,
    COUNT(DISTINCT USER_ID) AS UNIQUE_USERS
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
GROUP BY DATE_TRUNC('DAY', TIMESTAMP), RESPONSE_STATUS_CODE, SEMANTIC_MODEL_NAME;

-- ============================================================================
-- View 3: VW_WARNING_ANALYSIS - Warning patterns and frequencies
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_WARNING_ANALYSIS AS
SELECT 
    REQUEST_ID,
    TIMESTAMP,
    SEMANTIC_MODEL_NAME,
    USER_ID,
    LATEST_QUESTION,
    WARNINGS,
    ARRAY_SIZE(WARNINGS) AS WARNING_COUNT,
    RESPONSE_STATUS_CODE
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE WARNINGS IS NOT NULL 
  AND ARRAY_SIZE(WARNINGS) > 0;

-- ============================================================================
-- View 4: VW_FEEDBACK_SUMMARY - Feedback patterns by model and user
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_FEEDBACK_SUMMARY AS
SELECT 
    REQUEST_ID,
    TIMESTAMP,
    SEMANTIC_MODEL_NAME,
    USER_ID,
    USER_NAME,
    LATEST_QUESTION,
    GENERATED_SQL,
    FEEDBACK,
    ARRAY_SIZE(FEEDBACK) AS FEEDBACK_COUNT,
    RESPONSE_STATUS_CODE
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE FEEDBACK IS NOT NULL 
  AND ARRAY_SIZE(FEEDBACK) > 0;

-- ============================================================================
-- View 5: VW_SQL_COMPLEXITY_METRICS - SQL complexity analysis
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_SQL_COMPLEXITY_METRICS AS
SELECT 
    REQUEST_ID,
    TIMESTAMP,
    SEMANTIC_MODEL_NAME,
    USER_ID,
    LATEST_QUESTION,
    GENERATED_SQL,
    LENGTH(GENERATED_SQL) AS SQL_LENGTH,
    REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') AS JOIN_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') AS WHERE_CLAUSE_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') AS GROUP_BY_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'ORDER BY', 1, 'i') AS ORDER_BY_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'HAVING', 1, 'i') AS HAVING_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'CASE', 1, 'i') AS CASE_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'UNION', 1, 'i') AS UNION_COUNT,
    REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') AS SUBQUERY_COUNT,
    
    -- Calculate SQL complexity score
    (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
    (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') * 1) +
    (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'HAVING', 1, 'i') * 2) +
    (REGEXP_COUNT(GENERATED_SQL, 'CASE', 1, 'i') * 1.5) +
    (REGEXP_COUNT(GENERATED_SQL, 'UNION', 1, 'i') * 3) +
    (REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') * 2.5) AS SQL_COMPLEXITY_SCORE,
    
    CASE 
        WHEN (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') * 1) +
             (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'HAVING', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'CASE', 1, 'i') * 1.5) +
             (REGEXP_COUNT(GENERATED_SQL, 'UNION', 1, 'i') * 3) +
             (REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') * 2.5) < 5 THEN 'SIMPLE'
        WHEN (COALESCE(LENGTH(GENERATED_SQL), 0) / 100.0) + 
             (REGEXP_COUNT(GENERATED_SQL, 'JOIN', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'WHERE', 1, 'i') * 1) +
             (REGEXP_COUNT(GENERATED_SQL, 'GROUP BY', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'HAVING', 1, 'i') * 2) +
             (REGEXP_COUNT(GENERATED_SQL, 'CASE', 1, 'i') * 1.5) +
             (REGEXP_COUNT(GENERATED_SQL, 'UNION', 1, 'i') * 3) +
             (REGEXP_COUNT(GENERATED_SQL, 'SUBQUERY|\\(SELECT', 1, 'i') * 2.5) < 15 THEN 'MODERATE'
        ELSE 'COMPLEX'
    END AS COMPLEXITY_CATEGORY,
    
    FEEDBACK,
    ARRAY_SIZE(FEEDBACK) AS FEEDBACK_COUNT,
    RESPONSE_STATUS_CODE
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE GENERATED_SQL IS NOT NULL;

-- ============================================================================
-- View 6: VW_USER_ACTIVITY_SUMMARY - User activity and success rates
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_USER_ACTIVITY_SUMMARY AS
SELECT 
    USER_ID,
    USER_NAME,
    COUNT(*) AS TOTAL_REQUESTS,
    SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END) AS SUCCESSFUL_REQUESTS,
    SUM(CASE WHEN RESPONSE_STATUS_CODE != 200 THEN 1 ELSE 0 END) AS FAILED_REQUESTS,
    ROUND(SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END)::FLOAT / COUNT(*) * 100, 2) AS SUCCESS_RATE_PCT,
    SUM(CASE WHEN FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 THEN 1 ELSE 0 END) AS REQUESTS_WITH_FEEDBACK,
    MIN(TIMESTAMP) AS FIRST_REQUEST_TIME,
    MAX(TIMESTAMP) AS LAST_REQUEST_TIME
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
GROUP BY USER_ID, USER_NAME;

-- ============================================================================
-- View 7: VW_SEMANTIC_MODEL_PERFORMANCE - Model-level performance metrics
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_SEMANTIC_MODEL_PERFORMANCE AS
SELECT 
    SEMANTIC_MODEL_NAME,
    SEMANTIC_MODEL_TYPE,
    COUNT(*) AS TOTAL_REQUESTS,
    SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END) AS SUCCESSFUL_REQUESTS,
    SUM(CASE WHEN RESPONSE_STATUS_CODE != 200 THEN 1 ELSE 0 END) AS FAILED_REQUESTS,
    ROUND(SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END)::FLOAT / COUNT(*) * 100, 2) AS SUCCESS_RATE_PCT,
    SUM(CASE WHEN WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0 THEN 1 ELSE 0 END) AS REQUESTS_WITH_WARNINGS,
    SUM(CASE WHEN FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 THEN 1 ELSE 0 END) AS REQUESTS_WITH_FEEDBACK,
    COUNT(DISTINCT USER_ID) AS UNIQUE_USERS,
    AVG(LENGTH(GENERATED_SQL)) AS AVG_SQL_LENGTH
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
GROUP BY SEMANTIC_MODEL_NAME, SEMANTIC_MODEL_TYPE;

-- ============================================================================
-- View 8: VW_QUESTION_PATTERNS - Analyze question types and patterns
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_QUESTION_PATTERNS AS
SELECT 
    REQUEST_ID,
    TIMESTAMP,
    SEMANTIC_MODEL_NAME,
    USER_ID,
    LATEST_QUESTION,
    
    -- Categorize question types based on keywords
    CASE 
        WHEN LATEST_QUESTION ILIKE '%how many%' OR LATEST_QUESTION ILIKE '%count%' THEN 'COUNT_QUERY'
        WHEN LATEST_QUESTION ILIKE '%sum%' OR LATEST_QUESTION ILIKE '%total%' THEN 'AGGREGATION_QUERY'
        WHEN LATEST_QUESTION ILIKE '%average%' OR LATEST_QUESTION ILIKE '%avg%' OR LATEST_QUESTION ILIKE '%mean%' THEN 'AVERAGE_QUERY'
        WHEN LATEST_QUESTION ILIKE '%top%' OR LATEST_QUESTION ILIKE '%highest%' OR LATEST_QUESTION ILIKE '%maximum%' THEN 'TOP_N_QUERY'
        WHEN LATEST_QUESTION ILIKE '%bottom%' OR LATEST_QUESTION ILIKE '%lowest%' OR LATEST_QUESTION ILIKE '%minimum%' THEN 'BOTTOM_N_QUERY'
        WHEN LATEST_QUESTION ILIKE '%compare%' OR LATEST_QUESTION ILIKE '%comparison%' THEN 'COMPARISON_QUERY'
        WHEN LATEST_QUESTION ILIKE '%trend%' OR LATEST_QUESTION ILIKE '%over time%' THEN 'TREND_QUERY'
        WHEN LATEST_QUESTION ILIKE '%show%' OR LATEST_QUESTION ILIKE '%list%' OR LATEST_QUESTION ILIKE '%get%' THEN 'LIST_QUERY'
        WHEN LATEST_QUESTION ILIKE '%filter%' OR LATEST_QUESTION ILIKE '%where%' THEN 'FILTER_QUERY'
        ELSE 'OTHER_QUERY'
    END AS QUESTION_TYPE,
    
    LENGTH(LATEST_QUESTION) AS QUESTION_LENGTH,
    GENERATED_SQL,
    RESPONSE_STATUS_CODE,
    FEEDBACK,
    ARRAY_SIZE(FEEDBACK) AS FEEDBACK_COUNT
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
WHERE LATEST_QUESTION IS NOT NULL;

-- ============================================================================
-- View 9: VW_DAILY_METRICS - Daily aggregated metrics
-- ============================================================================
CREATE OR REPLACE VIEW CURSOR_DB.AI_QUESTION_INSIGHTS.VW_DAILY_METRICS AS
SELECT 
    DATE_TRUNC('DAY', TIMESTAMP) AS REQUEST_DATE,
    COUNT(*) AS TOTAL_REQUESTS,
    COUNT(DISTINCT USER_ID) AS UNIQUE_USERS,
    COUNT(DISTINCT SEMANTIC_MODEL_NAME) AS UNIQUE_MODELS,
    SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END) AS SUCCESSFUL_REQUESTS,
    SUM(CASE WHEN RESPONSE_STATUS_CODE != 200 THEN 1 ELSE 0 END) AS FAILED_REQUESTS,
    ROUND(SUM(CASE WHEN RESPONSE_STATUS_CODE = 200 THEN 1 ELSE 0 END)::FLOAT / COUNT(*) * 100, 2) AS SUCCESS_RATE_PCT,
    SUM(CASE WHEN WARNINGS IS NOT NULL AND ARRAY_SIZE(WARNINGS) > 0 THEN 1 ELSE 0 END) AS REQUESTS_WITH_WARNINGS,
    SUM(CASE WHEN FEEDBACK IS NOT NULL AND ARRAY_SIZE(FEEDBACK) > 0 THEN 1 ELSE 0 END) AS REQUESTS_WITH_FEEDBACK,
    AVG(LENGTH(GENERATED_SQL)) AS AVG_SQL_LENGTH
FROM CURSOR_DB.AI_QUESTION_INSIGHTS.CORTEX_ANALYST_REQUEST_HISTORY
GROUP BY DATE_TRUNC('DAY', TIMESTAMP);

-- ============================================================================
-- Grant SELECT on all views to SVC_CURSOR_ROLE
-- ============================================================================
GRANT SELECT ON ALL VIEWS IN SCHEMA CURSOR_DB.AI_QUESTION_INSIGHTS TO ROLE SVC_CURSOR_ROLE;



